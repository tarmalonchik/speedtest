// Code generated by go-enum DO NOT EDIT.
// Version:
// Revision:
// Build Date:
// Built By:

package entities

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strconv"
	"strings"
)

const (
	// ActionsInvalid is a Actions of type Invalid.
	ActionsInvalid Actions = iota
	// ActionsAdd is a Actions of type Add.
	ActionsAdd
	// ActionsRemove is a Actions of type Remove.
	ActionsRemove
)

var ErrInvalidActions = errors.New("not a valid Actions")

const _ActionsName = "invalidaddremove"

var _ActionsMap = map[Actions]string{
	ActionsInvalid: _ActionsName[0:7],
	ActionsAdd:     _ActionsName[7:10],
	ActionsRemove:  _ActionsName[10:16],
}

// String implements the Stringer interface.
func (x Actions) String() string {
	if str, ok := _ActionsMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Actions(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Actions) IsValid() bool {
	_, ok := _ActionsMap[x]
	return ok
}

var _ActionsValue = map[string]Actions{
	_ActionsName[0:7]:                    ActionsInvalid,
	strings.ToLower(_ActionsName[0:7]):   ActionsInvalid,
	_ActionsName[7:10]:                   ActionsAdd,
	strings.ToLower(_ActionsName[7:10]):  ActionsAdd,
	_ActionsName[10:16]:                  ActionsRemove,
	strings.ToLower(_ActionsName[10:16]): ActionsRemove,
}

// ParseActions attempts to convert a string to a Actions.
func ParseActions(name string) (Actions, error) {
	if x, ok := _ActionsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ActionsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Actions(0), fmt.Errorf("%s is %w", name, ErrInvalidActions)
}

var errActionsNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *Actions) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Actions(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = Actions(v)
	case string:
		*x, err = ParseActions(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = Actions(val), nil
			}
		}
	case []byte:
		*x, err = ParseActions(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = Actions(val), nil
			}
		}
	case Actions:
		*x = v
	case int:
		*x = Actions(v)
	case *Actions:
		if v == nil {
			return errActionsNilPtr
		}
		*x = *v
	case uint:
		*x = Actions(v)
	case uint64:
		*x = Actions(v)
	case *int:
		if v == nil {
			return errActionsNilPtr
		}
		*x = Actions(*v)
	case *int64:
		if v == nil {
			return errActionsNilPtr
		}
		*x = Actions(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = Actions(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errActionsNilPtr
		}
		*x = Actions(*v)
	case *uint:
		if v == nil {
			return errActionsNilPtr
		}
		*x = Actions(*v)
	case *uint64:
		if v == nil {
			return errActionsNilPtr
		}
		*x = Actions(*v)
	case *string:
		if v == nil {
			return errActionsNilPtr
		}
		*x, err = ParseActions(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = Actions(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x Actions) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullActions struct {
	Actions Actions
	Valid   bool
}

func NewNullActions(val interface{}) (x NullActions) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullActions) Scan(value interface{}) (err error) {
	if value == nil {
		x.Actions, x.Valid = Actions(0), false
		return
	}

	err = x.Actions.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullActions) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.Actions), nil
}

const (
	// PlatformTypeInvalid is a PlatformType of type Invalid.
	PlatformTypeInvalid PlatformType = iota
	// PlatformTypeIos is a PlatformType of type Ios.
	PlatformTypeIos
	// PlatformTypeAndroid is a PlatformType of type Android.
	PlatformTypeAndroid
	// PlatformTypeWindows is a PlatformType of type Windows.
	PlatformTypeWindows
	// PlatformTypeMacOs is a PlatformType of type Mac_os.
	PlatformTypeMacOs
)

var ErrInvalidPlatformType = errors.New("not a valid PlatformType")

const _PlatformTypeName = "invalidiosandroidwindowsmac_os"

var _PlatformTypeMap = map[PlatformType]string{
	PlatformTypeInvalid: _PlatformTypeName[0:7],
	PlatformTypeIos:     _PlatformTypeName[7:10],
	PlatformTypeAndroid: _PlatformTypeName[10:17],
	PlatformTypeWindows: _PlatformTypeName[17:24],
	PlatformTypeMacOs:   _PlatformTypeName[24:30],
}

// String implements the Stringer interface.
func (x PlatformType) String() string {
	if str, ok := _PlatformTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("PlatformType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x PlatformType) IsValid() bool {
	_, ok := _PlatformTypeMap[x]
	return ok
}

var _PlatformTypeValue = map[string]PlatformType{
	_PlatformTypeName[0:7]:                    PlatformTypeInvalid,
	strings.ToLower(_PlatformTypeName[0:7]):   PlatformTypeInvalid,
	_PlatformTypeName[7:10]:                   PlatformTypeIos,
	strings.ToLower(_PlatformTypeName[7:10]):  PlatformTypeIos,
	_PlatformTypeName[10:17]:                  PlatformTypeAndroid,
	strings.ToLower(_PlatformTypeName[10:17]): PlatformTypeAndroid,
	_PlatformTypeName[17:24]:                  PlatformTypeWindows,
	strings.ToLower(_PlatformTypeName[17:24]): PlatformTypeWindows,
	_PlatformTypeName[24:30]:                  PlatformTypeMacOs,
	strings.ToLower(_PlatformTypeName[24:30]): PlatformTypeMacOs,
}

// ParsePlatformType attempts to convert a string to a PlatformType.
func ParsePlatformType(name string) (PlatformType, error) {
	if x, ok := _PlatformTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _PlatformTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return PlatformType(0), fmt.Errorf("%s is %w", name, ErrInvalidPlatformType)
}

var errPlatformTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *PlatformType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = PlatformType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = PlatformType(v)
	case string:
		*x, err = ParsePlatformType(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = PlatformType(val), nil
			}
		}
	case []byte:
		*x, err = ParsePlatformType(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = PlatformType(val), nil
			}
		}
	case PlatformType:
		*x = v
	case int:
		*x = PlatformType(v)
	case *PlatformType:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = *v
	case uint:
		*x = PlatformType(v)
	case uint64:
		*x = PlatformType(v)
	case *int:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = PlatformType(*v)
	case *int64:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = PlatformType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = PlatformType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = PlatformType(*v)
	case *uint:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = PlatformType(*v)
	case *uint64:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x = PlatformType(*v)
	case *string:
		if v == nil {
			return errPlatformTypeNilPtr
		}
		*x, err = ParsePlatformType(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = PlatformType(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x PlatformType) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullPlatformType struct {
	PlatformType PlatformType
	Valid        bool
}

func NewNullPlatformType(val interface{}) (x NullPlatformType) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullPlatformType) Scan(value interface{}) (err error) {
	if value == nil {
		x.PlatformType, x.Valid = PlatformType(0), false
		return
	}

	err = x.PlatformType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullPlatformType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.PlatformType), nil
}

const (
	// ProtocolsVlessReality is a Protocols of type vless_reality.
	ProtocolsVlessReality Protocols = "vless_reality"
	// ProtocolsShadowsocks is a Protocols of type shadowsocks.
	ProtocolsShadowsocks Protocols = "shadowsocks"
)

var ErrInvalidProtocols = errors.New("not a valid Protocols")

// String implements the Stringer interface.
func (x Protocols) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x Protocols) IsValid() bool {
	_, err := ParseProtocols(string(x))
	return err == nil
}

var _ProtocolsValue = map[string]Protocols{
	"vless_reality": ProtocolsVlessReality,
	"shadowsocks":   ProtocolsShadowsocks,
}

// ParseProtocols attempts to convert a string to a Protocols.
func ParseProtocols(name string) (Protocols, error) {
	if x, ok := _ProtocolsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ProtocolsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Protocols(""), fmt.Errorf("%s is %w", name, ErrInvalidProtocols)
}

var errProtocolsNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntProtocolsMap = map[int64]Protocols{
	0: ProtocolsVlessReality,
	1: ProtocolsShadowsocks,
}

var sqlIntProtocolsValue = map[Protocols]int64{
	ProtocolsVlessReality: 0,
	ProtocolsShadowsocks:  1,
}

func lookupSqlIntProtocols(val int64) (Protocols, error) {
	x, ok := sqlIntProtocolsMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidProtocols)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *Protocols) Scan(value interface{}) (err error) {
	if value == nil {
		*x = Protocols("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntProtocols(v)
	case string:
		*x, err = ParseProtocols(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntProtocols(val)
		} else {
			// try parsing the value as a string
			*x, err = ParseProtocols(string(v))
		}
	case Protocols:
		*x = v
	case int:
		*x, err = lookupSqlIntProtocols(int64(v))
	case *Protocols:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntProtocols(int64(v))
	case uint64:
		*x, err = lookupSqlIntProtocols(int64(v))
	case *int:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = lookupSqlIntProtocols(int64(*v))
	case *int64:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = lookupSqlIntProtocols(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntProtocols(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = lookupSqlIntProtocols(int64(*v))
	case *uint:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = lookupSqlIntProtocols(int64(*v))
	case *uint64:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = lookupSqlIntProtocols(int64(*v))
	case *string:
		if v == nil {
			return errProtocolsNilPtr
		}
		*x, err = ParseProtocols(*v)
	default:
		return errors.New("invalid type for Protocols")
	}

	return
}

// Value implements the driver Valuer interface.
func (x Protocols) Value() (driver.Value, error) {
	val, ok := sqlIntProtocolsValue[x]
	if !ok {
		return nil, ErrInvalidProtocols
	}
	return int64(val), nil
}

type NullProtocols struct {
	Protocols Protocols
	Valid     bool
}

func NewNullProtocols(val interface{}) (x NullProtocols) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullProtocols) Scan(value interface{}) (err error) {
	if value == nil {
		x.Protocols, x.Valid = Protocols(""), false
		return
	}

	err = x.Protocols.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullProtocols) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.Protocols), nil
}

const (
	// ReviewForCurrentUsersValuesInvalid is a ReviewForCurrentUsersValues of type Invalid.
	ReviewForCurrentUsersValuesInvalid ReviewForCurrentUsersValues = iota
	// ReviewForCurrentUsersValuesGood is a ReviewForCurrentUsersValues of type Good.
	ReviewForCurrentUsersValuesGood
	// ReviewForCurrentUsersValuesNormal is a ReviewForCurrentUsersValues of type Normal.
	ReviewForCurrentUsersValuesNormal
	// ReviewForCurrentUsersValuesBadExpensive is a ReviewForCurrentUsersValues of type Bad_expensive.
	ReviewForCurrentUsersValuesBadExpensive
	// ReviewForCurrentUsersValuesBadDifficultToConnect is a ReviewForCurrentUsersValues of type Bad_difficult_to_connect.
	ReviewForCurrentUsersValuesBadDifficultToConnect
	// ReviewForCurrentUsersValuesBadDifficultToPay is a ReviewForCurrentUsersValues of type Bad_difficult_to_pay.
	ReviewForCurrentUsersValuesBadDifficultToPay
	// ReviewForCurrentUsersValuesBadVpnWorksBad is a ReviewForCurrentUsersValues of type Bad_vpn_works_bad.
	ReviewForCurrentUsersValuesBadVpnWorksBad
	// ReviewForCurrentUsersValuesBadSupportIsBad is a ReviewForCurrentUsersValues of type Bad_support_is_bad.
	ReviewForCurrentUsersValuesBadSupportIsBad
	// ReviewForCurrentUsersValuesBadSomethingElse is a ReviewForCurrentUsersValues of type Bad_something_else.
	ReviewForCurrentUsersValuesBadSomethingElse
)

var ErrInvalidReviewForCurrentUsersValues = errors.New("not a valid ReviewForCurrentUsersValues")

const _ReviewForCurrentUsersValuesName = "invalidgoodnormalbad_expensivebad_difficult_to_connectbad_difficult_to_paybad_vpn_works_badbad_support_is_badbad_something_else"

var _ReviewForCurrentUsersValuesMap = map[ReviewForCurrentUsersValues]string{
	ReviewForCurrentUsersValuesInvalid:               _ReviewForCurrentUsersValuesName[0:7],
	ReviewForCurrentUsersValuesGood:                  _ReviewForCurrentUsersValuesName[7:11],
	ReviewForCurrentUsersValuesNormal:                _ReviewForCurrentUsersValuesName[11:17],
	ReviewForCurrentUsersValuesBadExpensive:          _ReviewForCurrentUsersValuesName[17:30],
	ReviewForCurrentUsersValuesBadDifficultToConnect: _ReviewForCurrentUsersValuesName[30:54],
	ReviewForCurrentUsersValuesBadDifficultToPay:     _ReviewForCurrentUsersValuesName[54:74],
	ReviewForCurrentUsersValuesBadVpnWorksBad:        _ReviewForCurrentUsersValuesName[74:91],
	ReviewForCurrentUsersValuesBadSupportIsBad:       _ReviewForCurrentUsersValuesName[91:109],
	ReviewForCurrentUsersValuesBadSomethingElse:      _ReviewForCurrentUsersValuesName[109:127],
}

// String implements the Stringer interface.
func (x ReviewForCurrentUsersValues) String() string {
	if str, ok := _ReviewForCurrentUsersValuesMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewForCurrentUsersValues(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ReviewForCurrentUsersValues) IsValid() bool {
	_, ok := _ReviewForCurrentUsersValuesMap[x]
	return ok
}

var _ReviewForCurrentUsersValuesValue = map[string]ReviewForCurrentUsersValues{
	_ReviewForCurrentUsersValuesName[0:7]:                      ReviewForCurrentUsersValuesInvalid,
	strings.ToLower(_ReviewForCurrentUsersValuesName[0:7]):     ReviewForCurrentUsersValuesInvalid,
	_ReviewForCurrentUsersValuesName[7:11]:                     ReviewForCurrentUsersValuesGood,
	strings.ToLower(_ReviewForCurrentUsersValuesName[7:11]):    ReviewForCurrentUsersValuesGood,
	_ReviewForCurrentUsersValuesName[11:17]:                    ReviewForCurrentUsersValuesNormal,
	strings.ToLower(_ReviewForCurrentUsersValuesName[11:17]):   ReviewForCurrentUsersValuesNormal,
	_ReviewForCurrentUsersValuesName[17:30]:                    ReviewForCurrentUsersValuesBadExpensive,
	strings.ToLower(_ReviewForCurrentUsersValuesName[17:30]):   ReviewForCurrentUsersValuesBadExpensive,
	_ReviewForCurrentUsersValuesName[30:54]:                    ReviewForCurrentUsersValuesBadDifficultToConnect,
	strings.ToLower(_ReviewForCurrentUsersValuesName[30:54]):   ReviewForCurrentUsersValuesBadDifficultToConnect,
	_ReviewForCurrentUsersValuesName[54:74]:                    ReviewForCurrentUsersValuesBadDifficultToPay,
	strings.ToLower(_ReviewForCurrentUsersValuesName[54:74]):   ReviewForCurrentUsersValuesBadDifficultToPay,
	_ReviewForCurrentUsersValuesName[74:91]:                    ReviewForCurrentUsersValuesBadVpnWorksBad,
	strings.ToLower(_ReviewForCurrentUsersValuesName[74:91]):   ReviewForCurrentUsersValuesBadVpnWorksBad,
	_ReviewForCurrentUsersValuesName[91:109]:                   ReviewForCurrentUsersValuesBadSupportIsBad,
	strings.ToLower(_ReviewForCurrentUsersValuesName[91:109]):  ReviewForCurrentUsersValuesBadSupportIsBad,
	_ReviewForCurrentUsersValuesName[109:127]:                  ReviewForCurrentUsersValuesBadSomethingElse,
	strings.ToLower(_ReviewForCurrentUsersValuesName[109:127]): ReviewForCurrentUsersValuesBadSomethingElse,
}

// ParseReviewForCurrentUsersValues attempts to convert a string to a ReviewForCurrentUsersValues.
func ParseReviewForCurrentUsersValues(name string) (ReviewForCurrentUsersValues, error) {
	if x, ok := _ReviewForCurrentUsersValuesValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ReviewForCurrentUsersValuesValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ReviewForCurrentUsersValues(0), fmt.Errorf("%s is %w", name, ErrInvalidReviewForCurrentUsersValues)
}

var errReviewForCurrentUsersValuesNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ReviewForCurrentUsersValues) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ReviewForCurrentUsersValues(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = ReviewForCurrentUsersValues(v)
	case string:
		*x, err = ParseReviewForCurrentUsersValues(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = ReviewForCurrentUsersValues(val), nil
			}
		}
	case []byte:
		*x, err = ParseReviewForCurrentUsersValues(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = ReviewForCurrentUsersValues(val), nil
			}
		}
	case ReviewForCurrentUsersValues:
		*x = v
	case int:
		*x = ReviewForCurrentUsersValues(v)
	case *ReviewForCurrentUsersValues:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = *v
	case uint:
		*x = ReviewForCurrentUsersValues(v)
	case uint64:
		*x = ReviewForCurrentUsersValues(v)
	case *int:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = ReviewForCurrentUsersValues(*v)
	case *int64:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = ReviewForCurrentUsersValues(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = ReviewForCurrentUsersValues(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = ReviewForCurrentUsersValues(*v)
	case *uint:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = ReviewForCurrentUsersValues(*v)
	case *uint64:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x = ReviewForCurrentUsersValues(*v)
	case *string:
		if v == nil {
			return errReviewForCurrentUsersValuesNilPtr
		}
		*x, err = ParseReviewForCurrentUsersValues(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = ReviewForCurrentUsersValues(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x ReviewForCurrentUsersValues) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullReviewForCurrentUsersValues struct {
	ReviewForCurrentUsersValues ReviewForCurrentUsersValues
	Valid                       bool
}

func NewNullReviewForCurrentUsersValues(val interface{}) (x NullReviewForCurrentUsersValues) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullReviewForCurrentUsersValues) Scan(value interface{}) (err error) {
	if value == nil {
		x.ReviewForCurrentUsersValues, x.Valid = ReviewForCurrentUsersValues(0), false
		return
	}

	err = x.ReviewForCurrentUsersValues.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullReviewForCurrentUsersValues) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.ReviewForCurrentUsersValues), nil
}

const (
	// ReviewForOldUsersInvalid is a ReviewForOldUsers of type Invalid.
	ReviewForOldUsersInvalid ReviewForOldUsers = iota
	// ReviewForOldUsersExpensive is a ReviewForOldUsers of type Expensive.
	ReviewForOldUsersExpensive
	// ReviewForOldUsersDontKnowHowToConnect is a ReviewForOldUsers of type Dont_know_how_to_connect.
	ReviewForOldUsersDontKnowHowToConnect
	// ReviewForOldUsersDontKnowHowToPay is a ReviewForOldUsers of type Dont_know_how_to_pay.
	ReviewForOldUsersDontKnowHowToPay
	// ReviewForOldUsersVpnBadQuality is a ReviewForOldUsers of type Vpn_bad_quality.
	ReviewForOldUsersVpnBadQuality
	// ReviewForOldUsersDontNeedVpn is a ReviewForOldUsers of type Dont_need_vpn.
	ReviewForOldUsersDontNeedVpn
	// ReviewForOldUsersSomethingElse is a ReviewForOldUsers of type Something_else.
	ReviewForOldUsersSomethingElse
)

var ErrInvalidReviewForOldUsers = errors.New("not a valid ReviewForOldUsers")

const _ReviewForOldUsersName = "invalidexpensivedont_know_how_to_connectdont_know_how_to_payvpn_bad_qualitydont_need_vpnsomething_else"

var _ReviewForOldUsersMap = map[ReviewForOldUsers]string{
	ReviewForOldUsersInvalid:              _ReviewForOldUsersName[0:7],
	ReviewForOldUsersExpensive:            _ReviewForOldUsersName[7:16],
	ReviewForOldUsersDontKnowHowToConnect: _ReviewForOldUsersName[16:40],
	ReviewForOldUsersDontKnowHowToPay:     _ReviewForOldUsersName[40:60],
	ReviewForOldUsersVpnBadQuality:        _ReviewForOldUsersName[60:75],
	ReviewForOldUsersDontNeedVpn:          _ReviewForOldUsersName[75:88],
	ReviewForOldUsersSomethingElse:        _ReviewForOldUsersName[88:102],
}

// String implements the Stringer interface.
func (x ReviewForOldUsers) String() string {
	if str, ok := _ReviewForOldUsersMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewForOldUsers(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ReviewForOldUsers) IsValid() bool {
	_, ok := _ReviewForOldUsersMap[x]
	return ok
}

var _ReviewForOldUsersValue = map[string]ReviewForOldUsers{
	_ReviewForOldUsersName[0:7]:                     ReviewForOldUsersInvalid,
	strings.ToLower(_ReviewForOldUsersName[0:7]):    ReviewForOldUsersInvalid,
	_ReviewForOldUsersName[7:16]:                    ReviewForOldUsersExpensive,
	strings.ToLower(_ReviewForOldUsersName[7:16]):   ReviewForOldUsersExpensive,
	_ReviewForOldUsersName[16:40]:                   ReviewForOldUsersDontKnowHowToConnect,
	strings.ToLower(_ReviewForOldUsersName[16:40]):  ReviewForOldUsersDontKnowHowToConnect,
	_ReviewForOldUsersName[40:60]:                   ReviewForOldUsersDontKnowHowToPay,
	strings.ToLower(_ReviewForOldUsersName[40:60]):  ReviewForOldUsersDontKnowHowToPay,
	_ReviewForOldUsersName[60:75]:                   ReviewForOldUsersVpnBadQuality,
	strings.ToLower(_ReviewForOldUsersName[60:75]):  ReviewForOldUsersVpnBadQuality,
	_ReviewForOldUsersName[75:88]:                   ReviewForOldUsersDontNeedVpn,
	strings.ToLower(_ReviewForOldUsersName[75:88]):  ReviewForOldUsersDontNeedVpn,
	_ReviewForOldUsersName[88:102]:                  ReviewForOldUsersSomethingElse,
	strings.ToLower(_ReviewForOldUsersName[88:102]): ReviewForOldUsersSomethingElse,
}

// ParseReviewForOldUsers attempts to convert a string to a ReviewForOldUsers.
func ParseReviewForOldUsers(name string) (ReviewForOldUsers, error) {
	if x, ok := _ReviewForOldUsersValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ReviewForOldUsersValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ReviewForOldUsers(0), fmt.Errorf("%s is %w", name, ErrInvalidReviewForOldUsers)
}

var errReviewForOldUsersNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ReviewForOldUsers) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ReviewForOldUsers(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = ReviewForOldUsers(v)
	case string:
		*x, err = ParseReviewForOldUsers(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = ReviewForOldUsers(val), nil
			}
		}
	case []byte:
		*x, err = ParseReviewForOldUsers(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = ReviewForOldUsers(val), nil
			}
		}
	case ReviewForOldUsers:
		*x = v
	case int:
		*x = ReviewForOldUsers(v)
	case *ReviewForOldUsers:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = *v
	case uint:
		*x = ReviewForOldUsers(v)
	case uint64:
		*x = ReviewForOldUsers(v)
	case *int:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = ReviewForOldUsers(*v)
	case *int64:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = ReviewForOldUsers(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = ReviewForOldUsers(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = ReviewForOldUsers(*v)
	case *uint:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = ReviewForOldUsers(*v)
	case *uint64:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x = ReviewForOldUsers(*v)
	case *string:
		if v == nil {
			return errReviewForOldUsersNilPtr
		}
		*x, err = ParseReviewForOldUsers(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = ReviewForOldUsers(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x ReviewForOldUsers) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullReviewForOldUsers struct {
	ReviewForOldUsers ReviewForOldUsers
	Valid             bool
}

func NewNullReviewForOldUsers(val interface{}) (x NullReviewForOldUsers) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullReviewForOldUsers) Scan(value interface{}) (err error) {
	if value == nil {
		x.ReviewForOldUsers, x.Valid = ReviewForOldUsers(0), false
		return
	}

	err = x.ReviewForOldUsers.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullReviewForOldUsers) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.ReviewForOldUsers), nil
}

const (
	// ReviewTypeInvalid is a ReviewType of type Invalid.
	ReviewTypeInvalid ReviewType = iota
	// ReviewTypeReviewForCurrentUsers is a ReviewType of type Review_for_current_users.
	ReviewTypeReviewForCurrentUsers
	// ReviewTypeReviewForOldUsers is a ReviewType of type Review_for_old_users.
	ReviewTypeReviewForOldUsers
)

var ErrInvalidReviewType = errors.New("not a valid ReviewType")

const _ReviewTypeName = "invalidreview_for_current_usersreview_for_old_users"

var _ReviewTypeMap = map[ReviewType]string{
	ReviewTypeInvalid:               _ReviewTypeName[0:7],
	ReviewTypeReviewForCurrentUsers: _ReviewTypeName[7:31],
	ReviewTypeReviewForOldUsers:     _ReviewTypeName[31:51],
}

// String implements the Stringer interface.
func (x ReviewType) String() string {
	if str, ok := _ReviewTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("ReviewType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ReviewType) IsValid() bool {
	_, ok := _ReviewTypeMap[x]
	return ok
}

var _ReviewTypeValue = map[string]ReviewType{
	_ReviewTypeName[0:7]:                    ReviewTypeInvalid,
	strings.ToLower(_ReviewTypeName[0:7]):   ReviewTypeInvalid,
	_ReviewTypeName[7:31]:                   ReviewTypeReviewForCurrentUsers,
	strings.ToLower(_ReviewTypeName[7:31]):  ReviewTypeReviewForCurrentUsers,
	_ReviewTypeName[31:51]:                  ReviewTypeReviewForOldUsers,
	strings.ToLower(_ReviewTypeName[31:51]): ReviewTypeReviewForOldUsers,
}

// ParseReviewType attempts to convert a string to a ReviewType.
func ParseReviewType(name string) (ReviewType, error) {
	if x, ok := _ReviewTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _ReviewTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return ReviewType(0), fmt.Errorf("%s is %w", name, ErrInvalidReviewType)
}

var errReviewTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ReviewType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ReviewType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = ReviewType(v)
	case string:
		*x, err = ParseReviewType(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = ReviewType(val), nil
			}
		}
	case []byte:
		*x, err = ParseReviewType(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = ReviewType(val), nil
			}
		}
	case ReviewType:
		*x = v
	case int:
		*x = ReviewType(v)
	case *ReviewType:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = *v
	case uint:
		*x = ReviewType(v)
	case uint64:
		*x = ReviewType(v)
	case *int:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = ReviewType(*v)
	case *int64:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = ReviewType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = ReviewType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = ReviewType(*v)
	case *uint:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = ReviewType(*v)
	case *uint64:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x = ReviewType(*v)
	case *string:
		if v == nil {
			return errReviewTypeNilPtr
		}
		*x, err = ParseReviewType(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = ReviewType(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x ReviewType) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullReviewType struct {
	ReviewType ReviewType
	Valid      bool
}

func NewNullReviewType(val interface{}) (x NullReviewType) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullReviewType) Scan(value interface{}) (err error) {
	if value == nil {
		x.ReviewType, x.Valid = ReviewType(0), false
		return
	}

	err = x.ReviewType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullReviewType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.ReviewType), nil
}

const (
	// SubscriptionHealthTypeHealthy is a SubscriptionHealthType of type healthy.
	SubscriptionHealthTypeHealthy SubscriptionHealthType = "healthy"
	// SubscriptionHealthTypeWillEndSoon is a SubscriptionHealthType of type will_end_soon.
	SubscriptionHealthTypeWillEndSoon SubscriptionHealthType = "will_end_soon"
	// SubscriptionHealthTypeHasEnded is a SubscriptionHealthType of type has_ended.
	SubscriptionHealthTypeHasEnded SubscriptionHealthType = "has_ended"
	// SubscriptionHealthTypeNeverHadSubscription is a SubscriptionHealthType of type never_had_subscription.
	SubscriptionHealthTypeNeverHadSubscription SubscriptionHealthType = "never_had_subscription"
)

var ErrInvalidSubscriptionHealthType = errors.New("not a valid SubscriptionHealthType")

// String implements the Stringer interface.
func (x SubscriptionHealthType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x SubscriptionHealthType) IsValid() bool {
	_, err := ParseSubscriptionHealthType(string(x))
	return err == nil
}

var _SubscriptionHealthTypeValue = map[string]SubscriptionHealthType{
	"healthy":                SubscriptionHealthTypeHealthy,
	"will_end_soon":          SubscriptionHealthTypeWillEndSoon,
	"has_ended":              SubscriptionHealthTypeHasEnded,
	"never_had_subscription": SubscriptionHealthTypeNeverHadSubscription,
}

// ParseSubscriptionHealthType attempts to convert a string to a SubscriptionHealthType.
func ParseSubscriptionHealthType(name string) (SubscriptionHealthType, error) {
	if x, ok := _SubscriptionHealthTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _SubscriptionHealthTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return SubscriptionHealthType(""), fmt.Errorf("%s is %w", name, ErrInvalidSubscriptionHealthType)
}

var errSubscriptionHealthTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntSubscriptionHealthTypeMap = map[int64]SubscriptionHealthType{
	0: SubscriptionHealthTypeHealthy,
	1: SubscriptionHealthTypeWillEndSoon,
	2: SubscriptionHealthTypeHasEnded,
	3: SubscriptionHealthTypeNeverHadSubscription,
}

var sqlIntSubscriptionHealthTypeValue = map[SubscriptionHealthType]int64{
	SubscriptionHealthTypeHealthy:              0,
	SubscriptionHealthTypeWillEndSoon:          1,
	SubscriptionHealthTypeHasEnded:             2,
	SubscriptionHealthTypeNeverHadSubscription: 3,
}

func lookupSqlIntSubscriptionHealthType(val int64) (SubscriptionHealthType, error) {
	x, ok := sqlIntSubscriptionHealthTypeMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidSubscriptionHealthType)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *SubscriptionHealthType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = SubscriptionHealthType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntSubscriptionHealthType(v)
	case string:
		*x, err = ParseSubscriptionHealthType(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntSubscriptionHealthType(val)
		} else {
			// try parsing the value as a string
			*x, err = ParseSubscriptionHealthType(string(v))
		}
	case SubscriptionHealthType:
		*x = v
	case int:
		*x, err = lookupSqlIntSubscriptionHealthType(int64(v))
	case *SubscriptionHealthType:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntSubscriptionHealthType(int64(v))
	case uint64:
		*x, err = lookupSqlIntSubscriptionHealthType(int64(v))
	case *int:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = lookupSqlIntSubscriptionHealthType(int64(*v))
	case *int64:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = lookupSqlIntSubscriptionHealthType(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntSubscriptionHealthType(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = lookupSqlIntSubscriptionHealthType(int64(*v))
	case *uint:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = lookupSqlIntSubscriptionHealthType(int64(*v))
	case *uint64:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = lookupSqlIntSubscriptionHealthType(int64(*v))
	case *string:
		if v == nil {
			return errSubscriptionHealthTypeNilPtr
		}
		*x, err = ParseSubscriptionHealthType(*v)
	default:
		return errors.New("invalid type for SubscriptionHealthType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x SubscriptionHealthType) Value() (driver.Value, error) {
	val, ok := sqlIntSubscriptionHealthTypeValue[x]
	if !ok {
		return nil, ErrInvalidSubscriptionHealthType
	}
	return int64(val), nil
}

type NullSubscriptionHealthType struct {
	SubscriptionHealthType SubscriptionHealthType
	Valid                  bool
}

func NewNullSubscriptionHealthType(val interface{}) (x NullSubscriptionHealthType) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullSubscriptionHealthType) Scan(value interface{}) (err error) {
	if value == nil {
		x.SubscriptionHealthType, x.Valid = SubscriptionHealthType(""), false
		return
	}

	err = x.SubscriptionHealthType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullSubscriptionHealthType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.SubscriptionHealthType), nil
}

const (
	// UserEventTypeInvalid is a UserEventType of type Invalid.
	UserEventTypeInvalid UserEventType = iota
	// UserEventTypeDemo1DayActivated is a UserEventType of type Demo1DayActivated.
	UserEventTypeDemo1DayActivated
	// UserEventTypeDemo14DayActivated is a UserEventType of type Demo14DayActivated.
	UserEventTypeDemo14DayActivated
	// UserEventTypeSubscriptionActivated is a UserEventType of type SubscriptionActivated.
	UserEventTypeSubscriptionActivated
	// UserEventTypeSubscriptionDeactivated is a UserEventType of type SubscriptionDeactivated.
	UserEventTypeSubscriptionDeactivated
	// UserEventTypePromoActivated is a UserEventType of type PromoActivated.
	UserEventTypePromoActivated
	// UserEventTypeDeletedByAdmin is a UserEventType of type DeletedByAdmin.
	UserEventTypeDeletedByAdmin
	// UserEventTypeDemo3DayActivated is a UserEventType of type Demo3DayActivated.
	UserEventTypeDemo3DayActivated
	// UserEventTypeDemoActivated is a UserEventType of type DemoActivated.
	UserEventTypeDemoActivated
	// UserEventTypeClickedReferralButton is a UserEventType of type ClickedReferralButton.
	UserEventTypeClickedReferralButton
)

var ErrInvalidUserEventType = errors.New("not a valid UserEventType")

const _UserEventTypeName = "invaliddemo1DayActivateddemo14DayActivatedsubscriptionActivatedsubscriptionDeactivatedpromoActivateddeletedByAdmindemo3DayActivateddemoActivatedclickedReferralButton"

var _UserEventTypeMap = map[UserEventType]string{
	UserEventTypeInvalid:                 _UserEventTypeName[0:7],
	UserEventTypeDemo1DayActivated:       _UserEventTypeName[7:24],
	UserEventTypeDemo14DayActivated:      _UserEventTypeName[24:42],
	UserEventTypeSubscriptionActivated:   _UserEventTypeName[42:63],
	UserEventTypeSubscriptionDeactivated: _UserEventTypeName[63:86],
	UserEventTypePromoActivated:          _UserEventTypeName[86:100],
	UserEventTypeDeletedByAdmin:          _UserEventTypeName[100:114],
	UserEventTypeDemo3DayActivated:       _UserEventTypeName[114:131],
	UserEventTypeDemoActivated:           _UserEventTypeName[131:144],
	UserEventTypeClickedReferralButton:   _UserEventTypeName[144:165],
}

// String implements the Stringer interface.
func (x UserEventType) String() string {
	if str, ok := _UserEventTypeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("UserEventType(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserEventType) IsValid() bool {
	_, ok := _UserEventTypeMap[x]
	return ok
}

var _UserEventTypeValue = map[string]UserEventType{
	_UserEventTypeName[0:7]:                      UserEventTypeInvalid,
	strings.ToLower(_UserEventTypeName[0:7]):     UserEventTypeInvalid,
	_UserEventTypeName[7:24]:                     UserEventTypeDemo1DayActivated,
	strings.ToLower(_UserEventTypeName[7:24]):    UserEventTypeDemo1DayActivated,
	_UserEventTypeName[24:42]:                    UserEventTypeDemo14DayActivated,
	strings.ToLower(_UserEventTypeName[24:42]):   UserEventTypeDemo14DayActivated,
	_UserEventTypeName[42:63]:                    UserEventTypeSubscriptionActivated,
	strings.ToLower(_UserEventTypeName[42:63]):   UserEventTypeSubscriptionActivated,
	_UserEventTypeName[63:86]:                    UserEventTypeSubscriptionDeactivated,
	strings.ToLower(_UserEventTypeName[63:86]):   UserEventTypeSubscriptionDeactivated,
	_UserEventTypeName[86:100]:                   UserEventTypePromoActivated,
	strings.ToLower(_UserEventTypeName[86:100]):  UserEventTypePromoActivated,
	_UserEventTypeName[100:114]:                  UserEventTypeDeletedByAdmin,
	strings.ToLower(_UserEventTypeName[100:114]): UserEventTypeDeletedByAdmin,
	_UserEventTypeName[114:131]:                  UserEventTypeDemo3DayActivated,
	strings.ToLower(_UserEventTypeName[114:131]): UserEventTypeDemo3DayActivated,
	_UserEventTypeName[131:144]:                  UserEventTypeDemoActivated,
	strings.ToLower(_UserEventTypeName[131:144]): UserEventTypeDemoActivated,
	_UserEventTypeName[144:165]:                  UserEventTypeClickedReferralButton,
	strings.ToLower(_UserEventTypeName[144:165]): UserEventTypeClickedReferralButton,
}

// ParseUserEventType attempts to convert a string to a UserEventType.
func ParseUserEventType(name string) (UserEventType, error) {
	if x, ok := _UserEventTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _UserEventTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return UserEventType(0), fmt.Errorf("%s is %w", name, ErrInvalidUserEventType)
}

var errUserEventTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *UserEventType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UserEventType(0)
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x = UserEventType(v)
	case string:
		*x, err = ParseUserEventType(v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(v); verr == nil {
				*x, err = UserEventType(val), nil
			}
		}
	case []byte:
		*x, err = ParseUserEventType(string(v))
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(string(v)); verr == nil {
				*x, err = UserEventType(val), nil
			}
		}
	case UserEventType:
		*x = v
	case int:
		*x = UserEventType(v)
	case *UserEventType:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = *v
	case uint:
		*x = UserEventType(v)
	case uint64:
		*x = UserEventType(v)
	case *int:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = UserEventType(*v)
	case *int64:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = UserEventType(*v)
	case float64: // json marshals everything as a float64 if it's a number
		*x = UserEventType(v)
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = UserEventType(*v)
	case *uint:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = UserEventType(*v)
	case *uint64:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x = UserEventType(*v)
	case *string:
		if v == nil {
			return errUserEventTypeNilPtr
		}
		*x, err = ParseUserEventType(*v)
		if err != nil {
			// try parsing the integer value as a string
			if val, verr := strconv.Atoi(*v); verr == nil {
				*x, err = UserEventType(val), nil
			}
		}
	}

	return
}

// Value implements the driver Valuer interface.
func (x UserEventType) Value() (driver.Value, error) {
	return int64(x), nil
}

type NullUserEventType struct {
	UserEventType UserEventType
	Valid         bool
}

func NewNullUserEventType(val interface{}) (x NullUserEventType) {
	x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	return
}

// Scan implements the Scanner interface.
func (x *NullUserEventType) Scan(value interface{}) (err error) {
	if value == nil {
		x.UserEventType, x.Valid = UserEventType(0), false
		return
	}

	err = x.UserEventType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullUserEventType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return int64(x.UserEventType), nil
}

const (
	// UserNotificationTypeTGMSG is a UserNotificationType of type TG_MSG.
	UserNotificationTypeTGMSG UserNotificationType = "TG_MSG"
	// UserNotificationTypeTGCALLBACK is a UserNotificationType of type TG_CALL_BACK.
	UserNotificationTypeTGCALLBACK UserNotificationType = "TG_CALL_BACK"
	// UserNotificationTypeTGFILE is a UserNotificationType of type TG_FILE.
	UserNotificationTypeTGFILE UserNotificationType = "TG_FILE"
	// UserNotificationTypeEMAIL is a UserNotificationType of type EMAIL.
	UserNotificationTypeEMAIL UserNotificationType = "EMAIL"
)

var ErrInvalidUserNotificationType = errors.New("not a valid UserNotificationType")

// String implements the Stringer interface.
func (x UserNotificationType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserNotificationType) IsValid() bool {
	_, err := ParseUserNotificationType(string(x))
	return err == nil
}

var _UserNotificationTypeValue = map[string]UserNotificationType{
	"TG_MSG":       UserNotificationTypeTGMSG,
	"tg_msg":       UserNotificationTypeTGMSG,
	"TG_CALL_BACK": UserNotificationTypeTGCALLBACK,
	"tg_call_back": UserNotificationTypeTGCALLBACK,
	"TG_FILE":      UserNotificationTypeTGFILE,
	"tg_file":      UserNotificationTypeTGFILE,
	"EMAIL":        UserNotificationTypeEMAIL,
	"email":        UserNotificationTypeEMAIL,
}

// ParseUserNotificationType attempts to convert a string to a UserNotificationType.
func ParseUserNotificationType(name string) (UserNotificationType, error) {
	if x, ok := _UserNotificationTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _UserNotificationTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return UserNotificationType(""), fmt.Errorf("%s is %w", name, ErrInvalidUserNotificationType)
}

var errUserNotificationTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntUserNotificationTypeMap = map[int64]UserNotificationType{
	0: UserNotificationTypeTGMSG,
	1: UserNotificationTypeTGCALLBACK,
	2: UserNotificationTypeTGFILE,
	3: UserNotificationTypeEMAIL,
}

var sqlIntUserNotificationTypeValue = map[UserNotificationType]int64{
	UserNotificationTypeTGMSG:      0,
	UserNotificationTypeTGCALLBACK: 1,
	UserNotificationTypeTGFILE:     2,
	UserNotificationTypeEMAIL:      3,
}

func lookupSqlIntUserNotificationType(val int64) (UserNotificationType, error) {
	x, ok := sqlIntUserNotificationTypeMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidUserNotificationType)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *UserNotificationType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UserNotificationType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntUserNotificationType(v)
	case string:
		*x, err = ParseUserNotificationType(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntUserNotificationType(val)
		} else {
			// try parsing the value as a string
			*x, err = ParseUserNotificationType(string(v))
		}
	case UserNotificationType:
		*x = v
	case int:
		*x, err = lookupSqlIntUserNotificationType(int64(v))
	case *UserNotificationType:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntUserNotificationType(int64(v))
	case uint64:
		*x, err = lookupSqlIntUserNotificationType(int64(v))
	case *int:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = lookupSqlIntUserNotificationType(int64(*v))
	case *int64:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = lookupSqlIntUserNotificationType(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntUserNotificationType(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = lookupSqlIntUserNotificationType(int64(*v))
	case *uint:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = lookupSqlIntUserNotificationType(int64(*v))
	case *uint64:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = lookupSqlIntUserNotificationType(int64(*v))
	case *string:
		if v == nil {
			return errUserNotificationTypeNilPtr
		}
		*x, err = ParseUserNotificationType(*v)
	default:
		return errors.New("invalid type for UserNotificationType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x UserNotificationType) Value() (driver.Value, error) {
	val, ok := sqlIntUserNotificationTypeValue[x]
	if !ok {
		return nil, ErrInvalidUserNotificationType
	}
	return int64(val), nil
}

type NullUserNotificationType struct {
	UserNotificationType UserNotificationType
	Valid                bool
}

func NewNullUserNotificationType(val interface{}) (x NullUserNotificationType) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullUserNotificationType) Scan(value interface{}) (err error) {
	if value == nil {
		x.UserNotificationType, x.Valid = UserNotificationType(""), false
		return
	}

	err = x.UserNotificationType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullUserNotificationType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.UserNotificationType), nil
}

const (
	// UserSubscriptionTypeMANUAL is a UserSubscriptionType of type MANUAL.
	UserSubscriptionTypeMANUAL UserSubscriptionType = "MANUAL"
	// UserSubscriptionTypeAPPLEINAPP is a UserSubscriptionType of type APPLE_IN_APP.
	UserSubscriptionTypeAPPLEINAPP UserSubscriptionType = "APPLE_IN_APP"
	// UserSubscriptionTypeGOOGLEINAPP is a UserSubscriptionType of type GOOGLE_IN_APP.
	UserSubscriptionTypeGOOGLEINAPP UserSubscriptionType = "GOOGLE_IN_APP"
)

var ErrInvalidUserSubscriptionType = errors.New("not a valid UserSubscriptionType")

// String implements the Stringer interface.
func (x UserSubscriptionType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x UserSubscriptionType) IsValid() bool {
	_, err := ParseUserSubscriptionType(string(x))
	return err == nil
}

var _UserSubscriptionTypeValue = map[string]UserSubscriptionType{
	"MANUAL":        UserSubscriptionTypeMANUAL,
	"manual":        UserSubscriptionTypeMANUAL,
	"APPLE_IN_APP":  UserSubscriptionTypeAPPLEINAPP,
	"apple_in_app":  UserSubscriptionTypeAPPLEINAPP,
	"GOOGLE_IN_APP": UserSubscriptionTypeGOOGLEINAPP,
	"google_in_app": UserSubscriptionTypeGOOGLEINAPP,
}

// ParseUserSubscriptionType attempts to convert a string to a UserSubscriptionType.
func ParseUserSubscriptionType(name string) (UserSubscriptionType, error) {
	if x, ok := _UserSubscriptionTypeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _UserSubscriptionTypeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return UserSubscriptionType(""), fmt.Errorf("%s is %w", name, ErrInvalidUserSubscriptionType)
}

var errUserSubscriptionTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntUserSubscriptionTypeMap = map[int64]UserSubscriptionType{
	0: UserSubscriptionTypeMANUAL,
	1: UserSubscriptionTypeAPPLEINAPP,
	2: UserSubscriptionTypeGOOGLEINAPP,
}

var sqlIntUserSubscriptionTypeValue = map[UserSubscriptionType]int64{
	UserSubscriptionTypeMANUAL:      0,
	UserSubscriptionTypeAPPLEINAPP:  1,
	UserSubscriptionTypeGOOGLEINAPP: 2,
}

func lookupSqlIntUserSubscriptionType(val int64) (UserSubscriptionType, error) {
	x, ok := sqlIntUserSubscriptionTypeMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidUserSubscriptionType)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *UserSubscriptionType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = UserSubscriptionType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntUserSubscriptionType(v)
	case string:
		*x, err = ParseUserSubscriptionType(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntUserSubscriptionType(val)
		} else {
			// try parsing the value as a string
			*x, err = ParseUserSubscriptionType(string(v))
		}
	case UserSubscriptionType:
		*x = v
	case int:
		*x, err = lookupSqlIntUserSubscriptionType(int64(v))
	case *UserSubscriptionType:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntUserSubscriptionType(int64(v))
	case uint64:
		*x, err = lookupSqlIntUserSubscriptionType(int64(v))
	case *int:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = lookupSqlIntUserSubscriptionType(int64(*v))
	case *int64:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = lookupSqlIntUserSubscriptionType(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntUserSubscriptionType(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = lookupSqlIntUserSubscriptionType(int64(*v))
	case *uint:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = lookupSqlIntUserSubscriptionType(int64(*v))
	case *uint64:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = lookupSqlIntUserSubscriptionType(int64(*v))
	case *string:
		if v == nil {
			return errUserSubscriptionTypeNilPtr
		}
		*x, err = ParseUserSubscriptionType(*v)
	default:
		return errors.New("invalid type for UserSubscriptionType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x UserSubscriptionType) Value() (driver.Value, error) {
	val, ok := sqlIntUserSubscriptionTypeValue[x]
	if !ok {
		return nil, ErrInvalidUserSubscriptionType
	}
	return int64(val), nil
}

type NullUserSubscriptionType struct {
	UserSubscriptionType UserSubscriptionType
	Valid                bool
}

func NewNullUserSubscriptionType(val interface{}) (x NullUserSubscriptionType) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullUserSubscriptionType) Scan(value interface{}) (err error) {
	if value == nil {
		x.UserSubscriptionType, x.Valid = UserSubscriptionType(""), false
		return
	}

	err = x.UserSubscriptionType.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullUserSubscriptionType) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.UserSubscriptionType), nil
}

const (
	// VpnProtocolsInvalid is a VpnProtocols of type invalid.
	VpnProtocolsInvalid VpnProtocols = "invalid"
	// VpnProtocolsWireguard is a VpnProtocols of type wireguard.
	VpnProtocolsWireguard VpnProtocols = "wireguard"
	// VpnProtocolsXray is a VpnProtocols of type xray.
	VpnProtocolsXray VpnProtocols = "xray"
)

var ErrInvalidVpnProtocols = errors.New("not a valid VpnProtocols")

// String implements the Stringer interface.
func (x VpnProtocols) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VpnProtocols) IsValid() bool {
	_, err := ParseVpnProtocols(string(x))
	return err == nil
}

var _VpnProtocolsValue = map[string]VpnProtocols{
	"invalid":   VpnProtocolsInvalid,
	"wireguard": VpnProtocolsWireguard,
	"xray":      VpnProtocolsXray,
}

// ParseVpnProtocols attempts to convert a string to a VpnProtocols.
func ParseVpnProtocols(name string) (VpnProtocols, error) {
	if x, ok := _VpnProtocolsValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _VpnProtocolsValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return VpnProtocols(""), fmt.Errorf("%s is %w", name, ErrInvalidVpnProtocols)
}

var errVpnProtocolsNilPtr = errors.New("value pointer is nil") // one per type for package clashes

var sqlIntVpnProtocolsMap = map[int64]VpnProtocols{
	0: VpnProtocolsInvalid,
	1: VpnProtocolsWireguard,
	2: VpnProtocolsXray,
}

var sqlIntVpnProtocolsValue = map[VpnProtocols]int64{
	VpnProtocolsInvalid:   0,
	VpnProtocolsWireguard: 1,
	VpnProtocolsXray:      2,
}

func lookupSqlIntVpnProtocols(val int64) (VpnProtocols, error) {
	x, ok := sqlIntVpnProtocolsMap[val]
	if !ok {
		return x, fmt.Errorf("%v is not %w", val, ErrInvalidVpnProtocols)
	}
	return x, nil
}

// Scan implements the Scanner interface.
func (x *VpnProtocols) Scan(value interface{}) (err error) {
	if value == nil {
		*x = VpnProtocols("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case int64:
		*x, err = lookupSqlIntVpnProtocols(v)
	case string:
		*x, err = ParseVpnProtocols(v)
	case []byte:
		if val, verr := strconv.ParseInt(string(v), 10, 64); verr == nil {
			*x, err = lookupSqlIntVpnProtocols(val)
		} else {
			// try parsing the value as a string
			*x, err = ParseVpnProtocols(string(v))
		}
	case VpnProtocols:
		*x = v
	case int:
		*x, err = lookupSqlIntVpnProtocols(int64(v))
	case *VpnProtocols:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x = *v
	case uint:
		*x, err = lookupSqlIntVpnProtocols(int64(v))
	case uint64:
		*x, err = lookupSqlIntVpnProtocols(int64(v))
	case *int:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = lookupSqlIntVpnProtocols(int64(*v))
	case *int64:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = lookupSqlIntVpnProtocols(int64(*v))
	case float64: // json marshals everything as a float64 if it's a number
		*x, err = lookupSqlIntVpnProtocols(int64(v))
	case *float64: // json marshals everything as a float64 if it's a number
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = lookupSqlIntVpnProtocols(int64(*v))
	case *uint:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = lookupSqlIntVpnProtocols(int64(*v))
	case *uint64:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = lookupSqlIntVpnProtocols(int64(*v))
	case *string:
		if v == nil {
			return errVpnProtocolsNilPtr
		}
		*x, err = ParseVpnProtocols(*v)
	default:
		return errors.New("invalid type for VpnProtocols")
	}

	return
}

// Value implements the driver Valuer interface.
func (x VpnProtocols) Value() (driver.Value, error) {
	val, ok := sqlIntVpnProtocolsValue[x]
	if !ok {
		return nil, ErrInvalidVpnProtocols
	}
	return int64(val), nil
}

type NullVpnProtocols struct {
	VpnProtocols VpnProtocols
	Valid        bool
}

func NewNullVpnProtocols(val interface{}) (x NullVpnProtocols) {
	err := x.Scan(val) // yes, we ignore this error, it will just be an invalid value.
	_ = err            // make any errcheck linters happy
	return
}

// Scan implements the Scanner interface.
func (x *NullVpnProtocols) Scan(value interface{}) (err error) {
	if value == nil {
		x.VpnProtocols, x.Valid = VpnProtocols(""), false
		return
	}

	err = x.VpnProtocols.Scan(value)
	x.Valid = (err == nil)
	return
}

// Value implements the driver Valuer interface.
func (x NullVpnProtocols) Value() (driver.Value, error) {
	if !x.Valid {
		return nil, nil
	}
	// driver.Value accepts int64 for int values.
	return string(x.VpnProtocols), nil
}
